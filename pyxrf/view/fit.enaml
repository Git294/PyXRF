# ######################################################################
# Copyright (c) 2014, Brookhaven Science Associates, Brookhaven        #
# National Laboratory. All rights reserved.                            #
#                                                                      #
# Redistribution and use in source and binary forms, with or without   #
# modification, are permitted provided that the following conditions   #
# are met:                                                             #
#                                                                      #
# * Redistributions of source code must retain the above copyright     #
#   notice, this list of conditions and the following disclaimer.      #
#                                                                      #
# * Redistributions in binary form must reproduce the above copyright  #
#   notice this list of conditions and the following disclaimer in     #
#   the documentation and/or other materials provided with the         #
#   distribution.                                                      #
#                                                                      #
# * Neither the name of the Brookhaven Science Associates, Brookhaven  #
#   National Laboratory nor the names of its contributors may be used  #
#   to endorse or promote products derived from this software without  #
#   specific prior written permission.                                 #
#                                                                      #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    #
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS    #
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE       #
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,           #
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES   #
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR   #
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   #
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  #
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OTHERWISE) ARISING   #
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   #
# POSSIBILITY OF SUCH DAMAGE.                                          #
########################################################################
from __future__ import absolute_import
import numpy as np
import six

from enaml.widgets.api import (Container, PushButton, Label,
                               Form, Field, FileDialogEx, DockItem,
                               DockArea, CheckBox, ComboBox,
                               ScrollArea, Window, GroupBox, RadioButton,
                               MainWindow)

from enaml.widgets.api import RadioButton as DefaultRadioButton

from enaml.layout.api import hbox, vbox, HSplitLayout, VSplitLayout, TabLayout, spacer
from enaml.stdlib.fields import FloatField
from enaml.layout.geometry import Box
from enaml.core.api import Include, Looper

from enaml.stdlib.fields import FloatField as DefaultFloatField
from enaml.stdlib.fields import IntField as DefaultIntField

from ..model.guessparam import fit_strategy_list, save_as, bound_options
from skxray.core.fitting.xrf_model import (K_LINE, L_LINE, M_LINE)


enamldef FloatField(DefaultFloatField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef IntField(DefaultIntField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef RadioButton(DefaultRadioButton):
    minimum_size = (80, 20)

enamldef LabelTitle(Label):
    maximum_size = 80
    align = 'left'

#bound_options = ['none', 'lohi', 'fixed', 'lo', 'hi']

enamldef FitView(DockItem): fit_view:
    attr plot_model
    attr fit_model
    attr element_edit
    attr parameter_edit
    attr othersetting_edit
    attr img_model_adv

    Container:
        constraints = [
            vbox(
                hbox(new_param_load, reload_btn, lbl_param, spacer),
                hbox(lbl1, cb1, spacer),
                hbox(lbl2, cb2, spacer),
                hbox(lbl3, cb3, spacer),
                hbox(lbl4, cb4, spacer),
                hbox(lbl5, cb5, spacer),
                #hbox(gb_strategy),
                hbox(pb_fit, pb_cal, spacer),
                #hbox(pb_cal, spacer),
                gb_advanced,
                gb_result,
                hbox(saveas_btn, spacer),
                gb_fit_pixel,
            ),
        ]

        PushButton: new_param_load:
            text = 'Import Parameters from File'
            #maximum_size = 200
            clicked ::
                parameter_file_path = FileDialogEx.get_open_file_name(fit_view)
                if parameter_file_path:

                    # update parameter for fit
                    fit_model.read_param_from_file(parameter_file_path)
                    fit_model.apply_default_param()

                    # update experimental plots
                    plot_model.parameters = fit_model.default_parameters
                    plot_model.plot_experiment()
                    plot_model.plot_exp_opt = False
                    plot_model.plot_exp_opt = True

                    # update file name
                    lbl_param.text = 'Using parameter file: {}'.format(parameter_file_path.split('/')[-1])

                    # calculate profile and plot
                    fit_model.get_profile()

                    # update experimental plot with new calibration values
                    plot_model.fit_x = fit_model.cal_x
                    plot_model.fit_y = fit_model.cal_y
                    plot_model.fit_all = fit_model.cal_spectrum
                    plot_model.residual = fit_model.residual

                    plot_model.plot_fit()
                    # For plotting purposes, otherwise plot will not update
                    plot_model.show_fit_opt = False
                    plot_model.show_fit_opt = True


        PushButton: reload_btn:
            text = 'Reload'
            clicked ::
                fit_model.apply_default_param()

        Label: lbl_param:
            text = 'No parameter file is loaded.'

        Label: lbl1:
            text = 'Step 1'
        ComboBox: cb1:
            items = [''] + fit_strategy_list
            index = 0
            index := fit_model.fit_strategy1
        Label: lbl2:
            text = 'Step 2'
        ComboBox: cb2:
            items = [''] + fit_strategy_list
            index = 0
            index := fit_model.fit_strategy2
        Label: lbl3:
            text = 'Step 3'
        ComboBox: cb3:
            items = [''] + fit_strategy_list
            index = 0
            index := fit_model.fit_strategy3
        Label: lbl4:
            text = 'Step 4'
        ComboBox: cb4:
            items = [''] + fit_strategy_list
            index = 0
            index := fit_model.fit_strategy4
        Label: lbl5:
            text = 'Step 5'
        ComboBox: cb5:
            items = [''] + fit_strategy_list
            index = 0
            index := fit_model.fit_strategy5

        PushButton: pb_fit:
            text = 'Fit Summed Spectrum'
            clicked ::
                fit_model.fit_multiple()

                # BUG: line color for pileup is not correct from fit
                fit_model.get_profile()

                # update experimental plot with new calibration values
                plot_model.parameters = fit_model.param_dict
                plot_model.plot_experiment()

                #pb_plot.enabled = True
                plot_model.fit_x = fit_model.fit_x
                plot_model.fit_y = fit_model.fit_y

                # BUG!!!
                #plot_model.fit_all = fit_model.comps
                plot_model.fit_all = fit_model.cal_spectrum

                plot_model.residual = fit_model.residual
                plot_model.plot_fit()
                # For plotting purposes, otherwise plot will not update
                plot_model.show_fit_opt = False
                plot_model.show_fit_opt = True

        PushButton: pb_cal:
            text = 'Calculate Spectrum'
            clicked ::
                fit_model.get_profile()

                # update experimental plot with new calibration values
                plot_model.parameters = fit_model.param_dict
                plot_model.plot_experiment()

                #pb_plot.enabled = True
                plot_model.fit_x = fit_model.cal_x
                plot_model.fit_y = fit_model.cal_y
                plot_model.fit_all = fit_model.cal_spectrum
                plot_model.residual = fit_model.residual

                plot_model.plot_fit()
                # For plotting purposes, otherwise plot will not update
                plot_model.show_fit_opt = False
                plot_model.show_fit_opt = True

        #PushButton: pb_plot:
        #    text = 'Overlap to Spectrum'
        #    checkable = True
        #    enabled = False
        #    minimum_size = (200, 20)
        #    clicked ::
        #        if checked:
        #            plot_model.show_fit_opt = True
        #            pb_plot.text = 'Remove Plot'
        #        else:
        #            plot_model.show_fit_opt = False
        #            pb_plot.text = 'Overlap to Spectrum'

        GroupBox: gb_advanced:
            constraints = [vbox(
                                hbox(remove_btn, spacer),
                                hbox(cb_enable, element_btn, param_btn, spacer)
                                )]
            CheckBox: cb_enable:
                text = 'Enable Advanced Setting'
                clicked ::
                    if checked:
                        element_btn.enabled = True
                        param_btn.enabled = True
                    else:
                        element_btn.enabled = False
                        param_btn.enabled = False

            PushButton: element_btn:
                text = 'Edit Elements'
                enabled = False
                checkable = True
                checked := element_edit.visible
                clicked ::
                    if checked:
                        element_edit.show()
                    else:
                        element_edit.hide()

            PushButton: param_btn:
                text = 'Edit Global Fitting Parameters'
                enabled = False
                checkable = True
                checked := parameter_edit.visible
                clicked ::
                    if checked:
                        parameter_edit.show()
                    else:
                        parameter_edit.hide()

            PushButton: remove_btn:
                text = 'General Settings'
                enabled = True
                checkable = True
                checked := othersetting_edit.visible
                clicked ::
                    if checked:
                        othersetting_edit.show()
                    else:
                        othersetting_edit.hide()

        GroupBox: gb_result:
            title = 'Fitting Statistics'
            padding = Box(5, 5, 5, 5)
            constraints = [vbox(hbox(lbl_number, lbl_number_v, lbl_var_number, lbl_var_number_v, spacer),
                                hbox(lbl_chi, lbl_chi_v, lbl_red_chi, lbl_red_chi_v, spacer))]
            Label: lbl_number:
                text = '# of iterations'
                minimum_size = (140, 16)
            Label: lbl_number_v:
                text << str(fit_model.function_num)
                minimum_size = (140, 16)
            Label: lbl_var_number:
                text = '# of variables'
                minimum_size = (140, 16)
            Label: lbl_var_number_v:
                text << str(fit_model.nvar)
                minimum_size = (140, 16)
            Label: lbl_chi:
                text = 'chi-square'
                minimum_size = (140, 16)
            Label: lbl_chi_v:
                text << str(fit_model.chi2)
                minimum_size = (140, 16)
            Label: lbl_red_chi:
                text = 'reduced chi-square'
                minimum_size = (140, 16)
            Label: lbl_red_chi_v:
                text << str(fit_model.red_chi2)
                minimum_size = (140, 16)

        PushButton: saveas_btn:
            text = 'Save Config. File As'
            clicked ::
                path = FileDialogEx.get_save_file_name(fit_view,
                                                       current_path=fit_model.result_folder)
                if path:
                    save_as(path, fit_model.param_dict)

        GroupBox: gb_fit_pixel:
            title = 'Single Pixel Fitting'
            constraints = [vbox(hbox(save_cb, spacer),
                                hbox(lb1, fd1v, fd1h, lb2, fd2v, fd2h, spacer),
                                hbox(fit_pixel, spacer))]
            CheckBox: save_cb:
                text = 'Save plots from single pixel fitting'
                clicked ::
                    if checked:
                        fit_model.save_point = True
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True

                    else:
                        fit_model.save_point = False
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
            Label: lb1:
                text = 'Start Point: (vertical, horizontal)'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd1v:
                value := fit_model.point1v
                maximum_size = 40
                enabled = False
            IntField: fd1h:
                value := fit_model.point1h
                maximum_size = 40
                enabled = False
            Label: lb2:
                text = 'End Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd2v:
                value := fit_model.point2v
                maximum_size = 40
                enabled = False
            IntField: fd2h:
                value := fit_model.point2h
                maximum_size = 40
                enabled = False
            PushButton: fit_pixel:
                text = 'Fit Individual Pixel'
                clicked ::
                    fit_model.fit_single_pixel()
                    # add scalers to fit dict
                    scaler_key = [v for v in six.iterkeys(img_model_adv.data_dict) if 'scaler' in v]
                    if len(scaler_key) > 0:
                        fit_model.fit_img[fit_model.fit_img.keys()[0]].update(img_model_adv.data_dict[scaler_key[0]])

                    img_model_adv.data_dict.update(fit_model.fit_img)

                    # visualization purpose
                    img_model_adv.data_dict_keys = []
                    img_model_adv.data_dict_keys = img_model_adv.data_dict.keys()


enamldef ElementEdit(Window):
    attr parameter_model
    Container:
        constraints = [vbox(cmb_element,
                            hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        padding = Box(5, 5, 5, 5)
        ComboBox: cmb_element:
            items << ['Select Element'] + parameter_model.element_list
            index = 0
            index := parameter_model.selected_index
            #selected_item >> parameter_model.selected_element
        Label: lbl1:
            #text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
            text = '{:>16} {:>32} {:>32} {:>32} {:>16}'.format('name', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]

        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper: looper:
                    #iterable << sorted([k for k in six.iterkeys(parameter_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    #iterable << list(sorted([v for v in six.iterkeys(parameter_model.param_dict) if cmb_element.selected_item.split('_')[0] in str(v)]))
                    iterable << parameter_model.elementinfo_list

                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        constraints = [hbox(
                            ff_value, ff_min, ff_max,
                            cb_strat0, cb_strat1, cb_strat2,
                            cb_strat3, cb_strat4, cb_strat5, cb_strat6, spacer)
                        ]
                        FloatField: ff_value:
                            value := parameter_model.param_dict[loop_item]['value']
                            #minimum = parameter_model.param_dict[loop_item]['min']
                            #maximum = parameter_model.param_dict[loop_item]['max']
                        FloatField: ff_min:
                            value := parameter_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := parameter_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.selected_item  #items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef ParameterEdit(Window):
    attr parameter_model
    destroy_on_close = False
    Container:
        constraints = [vbox(hbox(lbl1, lbl2, lbl3, lbl4, lbl5, lbl6, lbl7, lbl8),
                            scr_area,)]
        padding = Box(5, 5, 5, 5)
        Label: lbl1:
            #text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
            text = '{:>16} {:>32} {:>32} {:>32} {:>16}'.format('name', 'value', 'min', 'max', '  ')
        Label: lbl2:
            text = fit_strategy_list[0]
        Label: lbl3:
            text = fit_strategy_list[1]
            background = 'grey'
        Label: lbl4:
            text = fit_strategy_list[2]
        Label: lbl5:
            text = fit_strategy_list[3]
            background = 'grey'
        Label: lbl6:
            text = fit_strategy_list[4]
        Label: lbl7:
            text = fit_strategy_list[5]
            background = 'grey'
        Label: lbl8:
            text = fit_strategy_list[6]
        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper: looper:
                    #iterable << sorted([k for k in six.iterkeys(parameter_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    iterable << parameter_model.global_param_list
                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [hbox(ff_value, ff_min, ff_max, cb_strat0, cb_strat1, cb_strat2, cb_strat3,
                                            cb_strat4, cb_strat5, cb_strat6,spacer)]
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        FloatField: ff_value:
                            value := parameter_model.param_dict[loop_item]['value']
                        FloatField: ff_min:
                            value := parameter_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := parameter_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat1.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat3.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            background = 'grey'
                            index ::
                                if cb_strat5.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef OtherSettingEdit(Window):
    attr fit_model
    #attr param_model
    attr plot_model
    attr edit_pileup

    Container :
        DockArea :
            layout = TabLayout('add_element', 'item_bkg', 'item_controller', 'item_controller_pixel', 'pileup')
            DockItem:
                closable = False
                name = 'add_element'
                title = 'Add/Remove Elements'
                GroupBox: pre_fit:
                    padding = Box(2, 2, 2, 2)
                    constraints = [vbox(hbox(cb_select, manual_add, spacer),
                                        scr_area_title,
                                        #hbox(manual_add),
                                        scr_area,),]
                                        #hbox(pb_delete_unselected, spacer),
                                        #hbox(pb_update, spacer),),]
                    ComboBox: cb_select:
                        items = ['Select Lines'] +\
                                K_LINE + L_LINE + M_LINE
                        index = 0
                        index ::
                            if cb_select.index > 0:
                                fit_model.e_name = cb_select.selected_item

                    #Label: intensity_lb:
                    #    text = 'Peak Int'

                    #FloatField: intensity_fd:
                    #    value := fit_model.add_element_intensity
                    #    submit_triggers = ['auto_sync']
                    #    maximum_size = 60

                    PushButton: manual_add:
                        text = 'Add'
                        clicked ::
                            fit_model.manual_input()

                    #PushButton: pileup_btn:
                    #    text = 'Pileup'
                    #    checkable = True
                    #    checked := edit_pileup.visible
                    #    clicked ::
                    #        if checked:
                    #            edit_pileup.show()
                    #        else:
                    #            edit_pileup.hide()

                    Container: scr_area_title:
                        padding = Box(2, 2, 2, 2)
                        constraints = [vbox(
                                           hbox(del_lb, z, name, energy, spacer),
                                           )
                                       ]
                        Label: del_lb:
                            text = '{:>10}'.format(' ')
                            minimum_size = (30, 20)
                        PushButton: z:
                            text = 'Z'
                            minimum_size = (30, 20)
                            #background = 'white'
                            clicked ::
                                fit_model.EC.order(option='z')
                                fit_model.update_name_list()
                        PushButton: name:
                            text = 'Names'
                            minimum_size = (120, 20)
                            maximum_size = 70
                            #background = 'white'
                            clicked ::
                                fit_model.EC.order(option='name')
                                fit_model.update_name_list()
                        PushButton: energy:
                            text = 'Energy'
                            maximum_size = 70
                            #background = 'white'
                            clicked ::
                                fit_model.EC.order(option='energy')
                                fit_model.update_name_list()
                        #PushButton: inten:
                        #    text = 'Peak Int'
                        #    minimum_size = (90, 20)
                        #    #background = 'white'
                        #    clicked ::
                        #        param_model.EC.order(option='maxv')
                        #        param_model.update_name_list()
                        #Label: norm:
                        #    text = 'Rel Int(%)'
                        #    minimum_size = (80, 20)
                        #    #background = 'white'
                        #    align = 'center'
                        #PushButton: select_all:
                        #    text = 'Show All'
                        #    #maximum_size = 30
                        #    minimum_size = (30, 20)
                        #    checkable = True
                        #    clicked ::
                        #        if checked:
                        #            param_model.EC.turn_on_all()
                        #            param_model.data_for_plot()
                        #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                        #                                                param_model.total_l, param_model.total_m,
                        #                                                param_model.total_pileup)
                        #            plot_model.show_autofit_opt = True
                        #            plot_model._fig.canvas.draw()
                        #            select_all.text = 'Hide All'
                        #        else:
                        #            param_model.EC.turn_on_all(option=False)
                        #            param_model.data_for_plot()
                        #            plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                        #                                                param_model.total_l, param_model.total_m,
                        #                                                param_model.total_pileup)
                        #            plot_model.show_autofit_opt = False
                        #            plot_model._fig.canvas.draw()
                        #            select_all.text = 'Show All'

                    ScrollArea: scr_area:
                        constraints = [height <= 350]

                        Form:
                        #Container: ctn_looper:
                            row_spacing = -1
                            #padding = Box(0, 0, 0, 0)
                            Looper: looper:
                                iterable << list(fit_model.result_dict_names)

                                PushButton: delete_btn:
                                    text = 'Del'
                                    clicked ::
                                        fit_model.EC.delete_item(loop_item)
                                        #fit_model.EC.update_peak_ratio()
                                        #param_model.data_for_plot()

                                        #plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                                        #                                    param_model.total_l, param_model.total_m,
                                        #                                    param_model.total_pileup)
                                        #plot_model._fig.canvas.draw()
                                        fit_model.update_name_list()

                                Container:
                                    padding = Box(2, 2, 2, 2)
                                    constraints = [hbox(delete_btn, lb_z, lb_name, lb_energy, spacer),]
                                                        #lb_norm.height==select_cb.height]

                                    Label: lb_z:
                                        text << fit_model.EC.element_dict[loop_item].z
                                        minimum_size = (40, 20)
                                        #background = 'white'
                                    Label: lb_name:
                                        text << loop_item
                                        minimum_size = (100, 20)
                                        #background = 'white'
                                    Label: lb_energy:
                                        text << str(fit_model.EC.element_dict[loop_item].energy)
                                        minimum_size = (60, 20)
                                        #maximum_size = 80
                                        #background = 'white'
                                    #FloatField: lb_inten:
                                    #    value := param_model.EC.element_dict[loop_item].maxv
                                    #    minimum_size = (60, 20)
                                    #    maximum_size = 80
                                    #    background = 'white'
                                    #    #align = 'right'
                                    #    minimum = 0.0

                                    #Label: lb_norm:
                                    #    text << set_low_bound(np.around(param_model.EC.element_dict[loop_item].norm, 2))
                                    #    minimum_size = (100, 20)
                                    #    #background = 'white'
                                    #    align = 'center'

                                    #CheckBox: select_cb:
                                    #    checkable = True
                                    #    minimum_size = (30, 20)
                                    #    checked := param_model.EC.element_dict[loop_item].status
                                    #    clicked ::
                                    #        param_model.EC.element_dict[loop_item].status = checked
                                    #        param_model.EC.element_dict[loop_item].stat_copy = param_model.EC.element_dict[loop_item].status
                                    #        param_model.data_for_plot()
                                    #        plot_model.set_prefit_data_and_plot(param_model.prefit_x, param_model.total_y,
                                    #                                            param_model.total_l, param_model.total_m,
                                    #                                            param_model.total_pileup)
                                    #        plot_model._fig.canvas.draw()


            DockItem:
                closable = False
                name = 'item_bkg'
                title = 'Background/Escape'
                Container:
                    Form:
                        Label:
                            text = 'Background width'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['background_width']
                        Label:
                            text = 'Escape peak'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['escape_ratio']
            DockItem:
                closable = False
                name = 'item_controller'
                title = 'Fitting Controller for Summed Spectrum'
                Container:
                    Form:
                        Label:
                            text = 'Max iteration number'
                        IntField:
                            value := fit_model.fit_num
                        Label:
                            text = 'Convergence criterion'
                        FloatField:
                            value := fit_model.ftol
                        Label:
                            text = 'Lower bound'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['energy_bound_low']['value']
                        Label:
                            text = 'Higher bound'
                        FloatField:
                            value := fit_model.param_dict['non_fitting_values']['energy_bound_high']['value']
                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight

            DockItem:
                closable = False
                name = 'item_controller_pixel'
                title = 'Fitting Controller for Single Pixels'
                Container:
                    Form:
                        Label:
                            text = 'Select fitting algorithm'
                        ComboBox: cb_algorithm:
                            items = ['non-negative leastsq', 'nonlinear leastsq']
                            index := fit_model.pixel_fit_method
                            #index ::
                            #    if index == 0:
                            #        fit_model.pixel_fit_method = 0
                            #    if index == 1:
                            #        fit_model.pixel_bin = 4
                        Label:
                            text = 'Max iteration number'
                        IntField:
                            value := fit_model.fit_num
                        Label:
                            text = 'Convergence criterion'
                        FloatField:
                            value := fit_model.ftol
                        Label:
                            text = 'Add const to background'
                        FloatField:
                            value := fit_model.raise_bg
                        Label:
                            text = 'Bin data on x,y positions'
                        ComboBox: cb_bin:
                            items = ['0', '2 by 2', '3 by 3']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.pixel_bin = 0
                                if index == 1:
                                    fit_model.pixel_bin = 4
                                if index == 2:
                                    fit_model.pixel_bin = 9
                        Label:
                            text = 'Use linear background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 1
                            index ::
                                if index == 0:
                                    fit_model.linear_bg = True
                                else:
                                    fit_model.linear_bg = False
                        Label:
                            text = 'Use snip method for background'
                        ComboBox:
                            items = ['Yes', 'No']
                            index = 0
                            index ::
                                if index == 0:
                                    fit_model.use_snip = True
                                else:
                                    fit_model.use_snip = False
                        Label:
                            text = 'Bin data on energy axis'
                        ComboBox:
                            items = ['0', '2', '3']
                            index = 0
                            index ::
                                fit_model.bin_energy = int(selected_item)

                        #Label:
                        #    text = 'Weighted c'
                        #FloatField:
                        #    value := fit_model.c_weight

            DockItem:
                closable = False
                name = 'pileup'
                title = 'Pileup Peak'
                Container:
                    Form:
                        Label: e1:
                            text = 'Element1, i.e. Si_Ka1'
                        Field: fd1:
                            text = ''
                        Label: e2:
                            text = 'Element2, i.e. Fe_Ka1'
                        Field: fd2:
                            text = ''
                        #Label: intensity:
                        #    text = 'Peak Int'
                        #FloatField: intensity_ff:
                        #    pass
                        PushButton: add_btn:
                            text = 'Add'
                            maximum_size = 60
                            clicked ::
                                fit_model.pileup_data['element1'] = fd1.text
                                fit_model.pileup_data['element2'] = fd2.text
                                #fit_model.pileup_data['intensity'] = intensity_ff.value
                                fit_model.add_pileup()
                                fit_model.update_name_list()
                                #param_model.data_for_plot()


def save_defaults(parameter_model):
    user_path = os.path.join(os.path.expanduser('~'), '.pyxrf',
                             'xrf_parameter_user.json')
    # format the dictionary
    dct = format_dict(parameter_model.parameters, parameter_model.element_list)
    json_out = json.dumps(dct)
    with open(user_path, 'w') as out_file:
        out_file.write(json_out)


enamldef EditPileupPeak(Window): pileup_win:
    attr fit_model
    title = 'Pileup Peak Editor'
    Container:
        Form:
            Label: e1:
                text = 'Element1'
            Field: fd1:
                text = ''
            Label: e2:
                text = 'Element2'
            Field: fd2:
                text = ''
            Label: intensity:
                text = 'Peak Int'
            FloatField: intensity_ff:
                pass
            PushButton: add_btn:
                text = 'Add'
                maximum_size = 60
                clicked ::
                    fit_model.pileup_data['element1'] = fd1.text
                    fit_model.pileup_data['element2'] = fd2.text
                    fit_model.pileup_data['intensity'] = intensity_ff.value
                    fit_model.add_pileup()
                    fit_model.update_name_list()
                    #param_model.data_for_plot()
                    pileup_win.close()
