# ######################################################################
# Copyright (c) 2014, Brookhaven Science Associates, Brookhaven        #
# National Laboratory. All rights reserved.                            #
#                                                                      #
# Redistribution and use in source and binary forms, with or without   #
# modification, are permitted provided that the following conditions   #
# are met:                                                             #
#                                                                      #
# * Redistributions of source code must retain the above copyright     #
#   notice, this list of conditions and the following disclaimer.      #
#                                                                      #
# * Redistributions in binary form must reproduce the above copyright  #
#   notice this list of conditions and the following disclaimer in     #
#   the documentation and/or other materials provided with the         #
#   distribution.                                                      #
#                                                                      #
# * Neither the name of the Brookhaven Science Associates, Brookhaven  #
#   National Laboratory nor the names of its contributors may be used  #
#   to endorse or promote products derived from this software without  #
#   specific prior written permission.                                 #
#                                                                      #
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  #
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    #
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS    #
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE       #
# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,           #
# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES   #
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR   #
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   #
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  #
# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OTHERWISE) ARISING   #
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   #
# POSSIBILITY OF SUCH DAMAGE.                                          #
########################################################################

import numpy as np
import six

from enaml.widgets.api import (Container, PushButton, Label,
                               Form, Field, FileDialogEx, DockItem,
                               DockArea, CheckBox, ComboBox,
                               ScrollArea, Window, GroupBox, RadioButton,
                               MainWindow)

from enaml.widgets.api import RadioButton as DefaultRadioButton

from enaml.layout.api import hbox, vbox, HSplitLayout, VSplitLayout, spacer
from enaml.stdlib.fields import FloatField
from enaml.layout.geometry import Box
from enaml.core.api import Include, Looper

from enaml.stdlib.fields import FloatField as DefaultFloatField
from enaml.stdlib.fields import IntField as DefaultIntField

from pyxrf.model.guessparam import fit_strategy_list, save_as


enamldef FloatField(DefaultFloatField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef IntField(DefaultIntField):
    submit_triggers = ['auto_sync'] #['return_pressed']

enamldef RadioButton(DefaultRadioButton):
    minimum_size = (80, 20)

enamldef LabelTitle(Label):
    maximum_size = 80
    align = 'left'

bound_options = ['none', 'lohi', 'fixed', 'lo', 'hi']

enamldef FitView(DockItem): fit_view:
    attr io_model
    attr param_model
    attr plot_model
    attr fit_model
    attr element_edit
    attr parameter_edit
    attr othersetting_edit
    attr img_model_adv

    Container:
        constraints = [
            vbox(
                hbox(reload_btn, spacer),
                hbox(lbl1, cb1, spacer),
                hbox(lbl2, cb2, spacer),
                hbox(lbl3, cb3, spacer),
                hbox(lbl4, cb4, spacer),
                hbox(lbl5, cb5, spacer),
                #hbox(gb_strategy),
                hbox(pb_fit, pb_cal, pb_plot, spacer),
                #hbox(pb_cal, spacer),
                gb_advanced,
                gb_result,
                hbox(saveas_btn, spacer),
                gb_fit_pixel,
            ),
        ]
        PushButton: reload_btn:
            text = 'Reload'
            clicked ::
                fit_model.get_new_param(param_model.param_new)

        Label: lbl1:
            text = 'Step 1'
        ComboBox: cb1:
            items = [''] + fit_strategy_list
            index = 0
            index >> fit_model.fit_strategy1
        Label: lbl2:
            text = 'Step 2'
        ComboBox: cb2:
            items = [''] + fit_strategy_list
            index = 0
            index >> fit_model.fit_strategy2
        Label: lbl3:
            text = 'Step 3'
        ComboBox: cb3:
            items = [''] + fit_strategy_list
            index = 0
            index >> fit_model.fit_strategy3
        Label: lbl4:
            text = 'Step 4'
        ComboBox: cb4:
            items = [''] + fit_strategy_list
            index = 0
            index >> fit_model.fit_strategy4
        Label: lbl5:
            text = 'Step 5'
        ComboBox: cb5:
            items = [''] + fit_strategy_list
            index = 0
            index >> fit_model.fit_strategy5

        PushButton: pb_fit:
            text = 'Fit Summed Spectrum'
            clicked ::
                fit_model.fit_multiple()

                # BUG: line color for pileup is not correct from fit
                fit_model.get_profile()

                # update experimental plot with new calibration values
                plot_model.parameters = fit_model.param_dict
                plot_model.plot_experiment()

                pb_plot.enabled = True
                plot_model.fit_x = fit_model.fit_x
                plot_model.fit_y = fit_model.fit_y

                # BUG!!!
                #plot_model.fit_all = fit_model.comps
                plot_model.fit_all = fit_model.cal_spectrum

                plot_model.residual = fit_model.residual
                plot_model.plot_fit()

        PushButton: pb_cal:
            text = 'Calculate Spectrum'
            clicked ::
                fit_model.get_profile()

                # update experimental plot with new calibration values
                plot_model.parameters = fit_model.param_dict
                plot_model.plot_experiment()

                pb_plot.enabled = True
                plot_model.fit_x = fit_model.cal_x
                plot_model.fit_y = fit_model.cal_y
                plot_model.fit_all = fit_model.cal_spectrum
                plot_model.residual = fit_model.residual

                plot_model.plot_fit()
                plot_model._update_canvas()

        PushButton: pb_plot:
            text = 'Overlap to Spectrum'
            checkable = True
            enabled = False
            minimum_size = (200, 20)
            clicked ::
                if checked:
                    plot_model.show_fit_opt = True
                    pb_plot.text = 'Remove Plot'
                else:
                    plot_model.show_fit_opt = False
                    pb_plot.text = 'Overlap to Spectrum'

        GroupBox: gb_advanced:
            constraints = [vbox(hbox(cb_enable, spacer),
                                hbox(element_btn, param_btn, other_btn, spacer))]
            CheckBox: cb_enable:
                text = 'Enable Advanced Setting'
                clicked ::
                    if checked:
                        element_btn.enabled = True
                        param_btn.enabled = True
                        other_btn.enabled = True
                    else:
                        element_btn.enabled = False
                        param_btn.enabled = False
                        other_btn.enabled = False

            PushButton: element_btn:
                text = 'Edit Elements'
                enabled = False
                checkable = True
                checked := element_edit.visible
                clicked ::
                    if checked:
                        element_edit.show()
                    else:
                        element_edit.hide()

            PushButton: param_btn:
                text = 'Edit Global Fitting Parameters'
                enabled = False
                checkable = True
                checked := parameter_edit.visible
                clicked ::
                    if checked:
                        parameter_edit.show()
                    else:
                        parameter_edit.hide()

            PushButton: other_btn:
                text = 'Other Settings'
                enabled = False
                checkable = True
                checked := othersetting_edit.visible
                clicked ::
                    if checked:
                        othersetting_edit.show()
                    else:
                        othersetting_edit.hide()

        GroupBox: gb_result:
            title = 'Fitting Statistics'
            padding = Box(5, 5, 5, 5)
            #Form:
            constraints = [vbox(hbox(lbl_number, lbl_number_v, lbl_var_number, lbl_var_number_v, spacer),
                                hbox(lbl_chi, lbl_chi_v, lbl_red_chi, lbl_red_chi_v, spacer))]
            #row_spacing = -1
            Label: lbl_number:
                text = '# function evals'
                minimum_size = (140, 16)
            Label: lbl_number_v:
                text << str(fit_model.function_num)
                minimum_size = (140, 16)
            Label: lbl_var_number:
                text = '# variables'
                minimum_size = (140, 16)
            Label: lbl_var_number_v:
                text << str(fit_model.nvar)
                minimum_size = (140, 16)
            Label: lbl_chi:
                text = 'chi-square'
                minimum_size = (140, 16)
            Label: lbl_chi_v:
                text << str(fit_model.chi2)
                minimum_size = (140, 16)
            Label: lbl_red_chi:
                text = 'reduced chi-square'
                minimum_size = (140, 16)
            Label: lbl_red_chi_v:
                text << str(fit_model.red_chi2)
                minimum_size = (140, 16)

        PushButton: saveas_btn:
            text = 'Save As'
            clicked ::
                path = FileDialogEx.get_save_file_name(fit_view,
                                                       current_path=io_model.working_directory)
                if path:
                    save_as(path, fit_model.param_dict)

        GroupBox: gb_fit_pixel:
            title = 'Single Pixel Fitting'
            constraints = [vbox(hbox(save_cb, spacer),
                                hbox(lb1, fd1v, fd1h, lb2, fd2v, fd2h, spacer),
                                hbox(fit_pixel, spacer))]
            CheckBox: save_cb:
                text = 'Save fitting output'
                clicked ::
                    if checked:
                        fit_model.save_point = True
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True

                    else:
                        fit_model.save_point = False
                        fd1v.enabled = True
                        fd1h.enabled = True
                        fd2v.enabled = True
                        fd2h.enabled = True
            Label: lb1:
                text = 'Start Point: (vertical, horizontal)'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd1v:
                value := fit_model.point1v
                maximum_size = 40
                enabled = False
            IntField: fd1h:
                value := fit_model.point1h
                maximum_size = 40
                enabled = False
            Label: lb2:
                text = 'End Point:'
                minimum_size = (40, 10)
                #maximum_size = 50
            IntField: fd2v:
                value := fit_model.point2v
                maximum_size = 40
                enabled = False
            IntField: fd2h:
                value := fit_model.point2h
                maximum_size = 40
                enabled = False
            PushButton: fit_pixel:
                text = 'Fit Individual Pixel'
                clicked ::
                    fit_model.fit_single_pixel()
                    temp_name = io_model.file_names[0].split('_')[0]+'_fit'
                    img_model_adv.data_dict.update(fit_model.fit_img)
                    img_model_adv.data_dict_keys = []
                    img_model_adv.data_dict_keys = img_model_adv.data_dict.keys()


enamldef ElementEdit(Window):
    attr parameter_model
    Container:
        padding = Box(5, 5, 5, 5)

        ComboBox: cmb_element:
            items << ['Select Element'] + sorted(parameter_model.element_list)
            index = 0
            selected_item >> parameter_model.selected_element
        Label: lbl:
            text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper: looper:
                    #iterable << sorted([k for k in six.iterkeys(parameter_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    #iterable << list(sorted([v for v in six.iterkeys(parameter_model.param_dict) if cmb_element.selected_item.split('_')[0] in str(v)]))
                    iterable << parameter_model.elementinfo_list

                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        constraints = [hbox(
                            ff_value, ff_min, ff_max,
                            cb_strat0, cb_strat1, cb_strat2,
                            cb_strat3, cb_strat4, cb_strat5, cb_strat6, spacer)
                        ]
                        FloatField: ff_value:
                            value := parameter_model.param_dict[loop_item]['value']
                            #minimum = parameter_model.param_dict[loop_item]['min']
                            #maximum = parameter_model.param_dict[loop_item]['max']
                        FloatField: ff_min:
                            value := parameter_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := parameter_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.selected_item  #items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat1.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat3.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat5.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef ParameterEdit(Window):
    attr parameter_model
    destroy_on_close = False
    Container:
        padding = Box(5, 5, 5, 5)
        Label: lbl:
            text = '{:>16} {:>32} {:>32} {:>32} {:>16} {:>40}'.format('name', 'value', 'min', 'max', '  ',  '  '.join(fit_strategy_list))
        ScrollArea: scr_area:
            constraints = [height <= 1000]
            Form:
                row_spacing = -1
                Looper: looper:
                    #iterable << sorted([k for k in six.iterkeys(parameter_model.param_dict) if k==k.lower() and k!='non_fitting_values'])
                    iterable << parameter_model.global_param_list
                    Label: name_lbl:
                        text = loop_item
                    Container:
                        padding = Box(2, 2, 2, 2)
                        constraints = [hbox(ff_value, ff_min, ff_max, cb_strat0, cb_strat1, cb_strat2, cb_strat3,
                                            cb_strat4, cb_strat5, cb_strat6,spacer)]
                        #constraints = [hbox(ff_value, ff_min, ff_max, spacer)]
                        FloatField: ff_value:
                            value := parameter_model.param_dict[loop_item]['value']
                        FloatField: ff_min:
                            value := parameter_model.param_dict[loop_item]['min']
                        FloatField: ff_max:
                            value := parameter_model.param_dict[loop_item]['max']

                        ComboBox: cb_strat0:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[0]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat0.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[0]] = cb_strat0.items[cb_strat0.index]

                        ComboBox: cb_strat1:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[1]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat1.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[1]] = cb_strat1.items[cb_strat1.index]

                        ComboBox: cb_strat2:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[2]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat2.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[2]] = cb_strat2.items[cb_strat2.index]

                        ComboBox: cb_strat3:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[3]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat3.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[3]] = cb_strat3.items[cb_strat3.index]

                        ComboBox: cb_strat4:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[4]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat4.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[4]] = cb_strat4.items[cb_strat4.index]

                        ComboBox: cb_strat5:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[5]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat5.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[5]] = cb_strat5.items[cb_strat5.index]

                        ComboBox: cb_strat6:
                            items = [' '] + bound_options
                            index = bound_options.index(parameter_model.param_dict[loop_item][fit_strategy_list[6]]) + 1
                            maximum_size = 80
                            index ::
                                if cb_strat6.index > 0:
                                    parameter_model.param_dict[loop_item][fit_strategy_list[6]] = cb_strat6.items[cb_strat6.index]


enamldef OtherSettingEdit(Window):
    attr fit_model
    destroy_on_close = False
    Form:
        Label:
            text = 'Max iteration number'
        IntField:
            value := fit_model.fit_num
        Label:
            text = 'Convergence criterion'
        FloatField:
            value := fit_model.ftol
        Label:
            text = 'Weighted c'
        FloatField:
            value := fit_model.c_weight


def save_defaults(parameter_model):
    user_path = os.path.join(os.path.expanduser('~'), '.pyxrf',
                             'xrf_parameter_user.json')
    # format the dictionary
    dct = format_dict(parameter_model.parameters, parameter_model.element_list)
    json_out = json.dumps(dct)
    with open(user_path, 'w') as out_file:
        out_file.write(json_out)

